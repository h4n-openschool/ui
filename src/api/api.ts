/* tslint:disable */
/* eslint-disable */
/**
 * OpenSchool API
 * Interact with your childrens\' teachers and their classes.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AuthLoginRequest
 */
export interface AuthLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthLoginRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AuthLoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AuthLoginResponse
 */
export interface AuthLoginResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthLoginResponse
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface Class
 */
export interface Class {
    /**
     * A cuid
     * @type {string}
     * @memberof Class
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Class
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Class
     */
    'displayName': string;
    /**
     * 
     * @type {string}
     * @memberof Class
     */
    'description': string;
    /**
     * An RFC3339 date/time string
     * @type {string}
     * @memberof Class
     */
    'createdAt': string;
    /**
     * An RFC3339 date/time string
     * @type {string}
     * @memberof Class
     */
    'updatedAt': string;
}
/**
 * An array of Classes
 * @export
 * @interface ClassList
 */
export interface ClassList extends Array<Class> {
}
/**
 * 
 * @export
 * @interface ClassesCreateRequest
 */
export interface ClassesCreateRequest {
    /**
     * The name of the Class
     * @type {string}
     * @memberof ClassesCreateRequest
     */
    'name'?: string;
    /**
     * The display name of the Class
     * @type {string}
     * @memberof ClassesCreateRequest
     */
    'displayName': string;
    /**
     * The description of the Class
     * @type {string}
     * @memberof ClassesCreateRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface ClassesCreateResponse
 */
export interface ClassesCreateResponse {
    /**
     * 
     * @type {Class}
     * @memberof ClassesCreateResponse
     */
    'class': Class;
}
/**
 * 
 * @export
 * @interface ClassesDelete200Response
 */
export interface ClassesDelete200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ClassesDelete200Response
     */
    'ok': boolean;
}
/**
 * 
 * @export
 * @interface ClassesGet200Response
 */
export interface ClassesGet200Response {
    /**
     * 
     * @type {Class}
     * @memberof ClassesGet200Response
     */
    'class': Class;
}
/**
 * The response for the /v1/classes endpoint
 * @export
 * @interface ClassesListResponse
 */
export interface ClassesListResponse {
    /**
     * 
     * @type {PaginationData}
     * @memberof ClassesListResponse
     */
    'pagination': PaginationData;
    /**
     * 
     * @type {ClassList}
     * @memberof ClassesListResponse
     */
    'classes': ClassList;
}
/**
 * 
 * @export
 * @interface ClassesUpdateRequest
 */
export interface ClassesUpdateRequest {
    /**
     * The name of the Class
     * @type {string}
     * @memberof ClassesUpdateRequest
     */
    'name'?: string;
    /**
     * The display name of the Class
     * @type {string}
     * @memberof ClassesUpdateRequest
     */
    'displayName'?: string;
    /**
     * The description of the Class
     * @type {string}
     * @memberof ClassesUpdateRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface ClassesUpdateResponse
 */
export interface ClassesUpdateResponse {
    /**
     * 
     * @type {Class}
     * @memberof ClassesUpdateResponse
     */
    'class': Class;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * The HTTP error code
     * @type {number}
     * @memberof ModelError
     */
    'code': number;
    /**
     * A human readable error message
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface MultiError
 */
export interface MultiError {
    /**
     * The HTTP error code
     * @type {number}
     * @memberof MultiError
     */
    'code': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof MultiError
     */
    'messages': Array<string>;
}
/**
 * 
 * @export
 * @interface PaginationData
 */
export interface PaginationData {
    /**
     * 
     * @type {number}
     * @memberof PaginationData
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationData
     */
    'perPage': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationData
     */
    'total': number;
    /**
     * 
     * @type {string}
     * @memberof PaginationData
     */
    'nextUrl': string;
    /**
     * 
     * @type {string}
     * @memberof PaginationData
     */
    'prevUrl': string;
    /**
     * 
     * @type {string}
     * @memberof PaginationData
     */
    'firstUrl': string;
    /**
     * 
     * @type {string}
     * @memberof PaginationData
     */
    'lastUrl': string;
}
/**
 * 
 * @export
 * @interface Student
 */
export interface Student {
    /**
     * A cuid
     * @type {string}
     * @memberof Student
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'fullName': string;
    /**
     * An RFC3339 date/time string
     * @type {string}
     * @memberof Student
     */
    'createdAt': string;
    /**
     * An RFC3339 date/time string
     * @type {string}
     * @memberof Student
     */
    'updatedAt': string;
}
/**
 * An array of Students
 * @export
 * @interface StudentList
 */
export interface StudentList extends Array<Student> {
}
/**
 * 
 * @export
 * @interface StudentsCreateRequest
 */
export interface StudentsCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof StudentsCreateRequest
     */
    'fullName': string;
}
/**
 * 
 * @export
 * @interface StudentsCreateResponse
 */
export interface StudentsCreateResponse {
    /**
     * 
     * @type {Student}
     * @memberof StudentsCreateResponse
     */
    'student': Student;
}
/**
 * 
 * @export
 * @interface StudentsGet200Response
 */
export interface StudentsGet200Response {
    /**
     * 
     * @type {Student}
     * @memberof StudentsGet200Response
     */
    'teacher'?: Student;
}
/**
 * The response for the /v1/teachers endpoint
 * @export
 * @interface StudentsListResponse
 */
export interface StudentsListResponse {
    /**
     * 
     * @type {PaginationData}
     * @memberof StudentsListResponse
     */
    'pagination': PaginationData;
    /**
     * 
     * @type {StudentList}
     * @memberof StudentsListResponse
     */
    'students': StudentList;
}
/**
 * 
 * @export
 * @interface StudentsUpdateRequest
 */
export interface StudentsUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof StudentsUpdateRequest
     */
    'fullName': string;
}
/**
 * 
 * @export
 * @interface StudentsUpdateResponse
 */
export interface StudentsUpdateResponse {
    /**
     * 
     * @type {Student}
     * @memberof StudentsUpdateResponse
     */
    'student': Student;
}
/**
 * 
 * @export
 * @interface Teacher
 */
export interface Teacher {
    /**
     * A cuid
     * @type {string}
     * @memberof Teacher
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    'email': string;
    /**
     * An RFC3339 date/time string
     * @type {string}
     * @memberof Teacher
     */
    'createdAt': string;
    /**
     * An RFC3339 date/time string
     * @type {string}
     * @memberof Teacher
     */
    'updatedAt': string;
}
/**
 * An array of Teachers
 * @export
 * @interface TeacherList
 */
export interface TeacherList extends Array<Teacher> {
}
/**
 * 
 * @export
 * @interface TeachersCreateRequest
 */
export interface TeachersCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof TeachersCreateRequest
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof TeachersCreateRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface TeachersCreateResponse
 */
export interface TeachersCreateResponse {
    /**
     * 
     * @type {Teacher}
     * @memberof TeachersCreateResponse
     */
    'teacher': Teacher;
}
/**
 * 
 * @export
 * @interface TeachersGet200Response
 */
export interface TeachersGet200Response {
    /**
     * 
     * @type {Teacher}
     * @memberof TeachersGet200Response
     */
    'teacher'?: Teacher;
}
/**
 * The response for the /v1/teachers endpoint
 * @export
 * @interface TeachersListResponse
 */
export interface TeachersListResponse {
    /**
     * 
     * @type {PaginationData}
     * @memberof TeachersListResponse
     */
    'pagination': PaginationData;
    /**
     * 
     * @type {TeacherList}
     * @memberof TeachersListResponse
     */
    'teachers': TeacherList;
}
/**
 * 
 * @export
 * @interface TeachersUpdateRequest
 */
export interface TeachersUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof TeachersUpdateRequest
     */
    'fullName': string;
    /**
     * 
     * @type {string}
     * @memberof TeachersUpdateRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface TeachersUpdateResponse
 */
export interface TeachersUpdateResponse {
    /**
     * 
     * @type {Teacher}
     * @memberof TeachersUpdateResponse
     */
    'teacher': Teacher;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Use a JWT to get the currently-authenticated user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCurrentUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate a JWT to use as a bearer token for authentication.
         * @param {AuthLoginRequest} authLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogin: async (authLoginRequest: AuthLoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authLoginRequest' is not null or undefined
            assertParamExists('authLogin', 'authLoginRequest', authLoginRequest)
            const localVarPath = `/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Use a JWT to get the currently-authenticated user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authCurrentUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Teacher>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authCurrentUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate a JWT to use as a bearer token for authentication.
         * @param {AuthLoginRequest} authLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogin(authLoginRequest: AuthLoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthLoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogin(authLoginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Use a JWT to get the currently-authenticated user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCurrentUser(options?: any): AxiosPromise<Teacher> {
            return localVarFp.authCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate a JWT to use as a bearer token for authentication.
         * @param {AuthLoginRequest} authLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogin(authLoginRequest: AuthLoginRequest, options?: any): AxiosPromise<AuthLoginResponse> {
            return localVarFp.authLogin(authLoginRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Use a JWT to get the currently-authenticated user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authCurrentUser(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate a JWT to use as a bearer token for authentication.
     * @param {AuthLoginRequest} authLoginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLogin(authLoginRequest: AuthLoginRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLogin(authLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClassesApi - axios parameter creator
 * @export
 */
export const ClassesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new class
         * @param {ClassesCreateRequest} classesCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesCreate: async (classesCreateRequest: ClassesCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'classesCreateRequest' is not null or undefined
            assertParamExists('classesCreate', 'classesCreateRequest', classesCreateRequest)
            const localVarPath = `/v1/classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a class by its CUID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classesDelete', 'id', id)
            const localVarPath = `/v1/classes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a class by its CUID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classesGet', 'id', id)
            const localVarPath = `/v1/classes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all classes
         * @param {number} [perPage] The number of results to retrieve in each page.
         * @param {number} [page] The page to load.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesList: async (perPage?: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a class by its CUID
         * @param {string} id 
         * @param {ClassesUpdateRequest} classesUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesUpdate: async (id: string, classesUpdateRequest: ClassesUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('classesUpdate', 'id', id)
            // verify required parameter 'classesUpdateRequest' is not null or undefined
            assertParamExists('classesUpdate', 'classesUpdateRequest', classesUpdateRequest)
            const localVarPath = `/v1/classes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classesUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClassesApi - functional programming interface
 * @export
 */
export const ClassesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClassesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new class
         * @param {ClassesCreateRequest} classesCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesCreate(classesCreateRequest: ClassesCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesCreate(classesCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a class by its CUID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassesDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a class by its CUID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all classes
         * @param {number} [perPage] The number of results to retrieve in each page.
         * @param {number} [page] The page to load.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesList(perPage?: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesList(perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a class by its CUID
         * @param {string} id 
         * @param {ClassesUpdateRequest} classesUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classesUpdate(id: string, classesUpdateRequest: ClassesUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassesUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classesUpdate(id, classesUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClassesApi - factory interface
 * @export
 */
export const ClassesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClassesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new class
         * @param {ClassesCreateRequest} classesCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesCreate(classesCreateRequest: ClassesCreateRequest, options?: any): AxiosPromise<ClassesCreateResponse> {
            return localVarFp.classesCreate(classesCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a class by its CUID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesDelete(id: string, options?: any): AxiosPromise<ClassesDelete200Response> {
            return localVarFp.classesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a class by its CUID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesGet(id: string, options?: any): AxiosPromise<ClassesGet200Response> {
            return localVarFp.classesGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all classes
         * @param {number} [perPage] The number of results to retrieve in each page.
         * @param {number} [page] The page to load.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesList(perPage?: number, page?: number, options?: any): AxiosPromise<ClassesListResponse> {
            return localVarFp.classesList(perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a class by its CUID
         * @param {string} id 
         * @param {ClassesUpdateRequest} classesUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classesUpdate(id: string, classesUpdateRequest: ClassesUpdateRequest, options?: any): AxiosPromise<ClassesUpdateResponse> {
            return localVarFp.classesUpdate(id, classesUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClassesApi - object-oriented interface
 * @export
 * @class ClassesApi
 * @extends {BaseAPI}
 */
export class ClassesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new class
     * @param {ClassesCreateRequest} classesCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesCreate(classesCreateRequest: ClassesCreateRequest, options?: AxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesCreate(classesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a class by its CUID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesDelete(id: string, options?: AxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a class by its CUID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesGet(id: string, options?: AxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all classes
     * @param {number} [perPage] The number of results to retrieve in each page.
     * @param {number} [page] The page to load.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesList(perPage?: number, page?: number, options?: AxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesList(perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a class by its CUID
     * @param {string} id 
     * @param {ClassesUpdateRequest} classesUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassesApi
     */
    public classesUpdate(id: string, classesUpdateRequest: ClassesUpdateRequest, options?: AxiosRequestConfig) {
        return ClassesApiFp(this.configuration).classesUpdate(id, classesUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudentsApi - axios parameter creator
 * @export
 */
export const StudentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new student
         * @param {StudentsCreateRequest} studentsCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentsCreate: async (studentsCreateRequest: StudentsCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studentsCreateRequest' is not null or undefined
            assertParamExists('studentsCreate', 'studentsCreateRequest', studentsCreateRequest)
            const localVarPath = `/v1/students`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studentsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a student by its CUID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentsDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studentsDelete', 'id', id)
            const localVarPath = `/v1/students/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a student by its CUID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentsGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studentsGet', 'id', id)
            const localVarPath = `/v1/students/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all students
         * @param {number} [perPage] The number of results to retrieve in each page.
         * @param {number} [page] The page to load.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentsList: async (perPage?: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/students`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a student by its CUID
         * @param {string} id 
         * @param {StudentsUpdateRequest} studentsUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentsUpdate: async (id: string, studentsUpdateRequest: StudentsUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('studentsUpdate', 'id', id)
            // verify required parameter 'studentsUpdateRequest' is not null or undefined
            assertParamExists('studentsUpdate', 'studentsUpdateRequest', studentsUpdateRequest)
            const localVarPath = `/v1/students/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studentsUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudentsApi - functional programming interface
 * @export
 */
export const StudentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new student
         * @param {StudentsCreateRequest} studentsCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentsCreate(studentsCreateRequest: StudentsCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentsCreate(studentsCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a student by its CUID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentsDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassesDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a student by its CUID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentsGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentsGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all students
         * @param {number} [perPage] The number of results to retrieve in each page.
         * @param {number} [page] The page to load.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentsList(perPage?: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentsList(perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a student by its CUID
         * @param {string} id 
         * @param {StudentsUpdateRequest} studentsUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async studentsUpdate(id: string, studentsUpdateRequest: StudentsUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentsUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.studentsUpdate(id, studentsUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudentsApi - factory interface
 * @export
 */
export const StudentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new student
         * @param {StudentsCreateRequest} studentsCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentsCreate(studentsCreateRequest: StudentsCreateRequest, options?: any): AxiosPromise<StudentsCreateResponse> {
            return localVarFp.studentsCreate(studentsCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a student by its CUID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentsDelete(id: string, options?: any): AxiosPromise<ClassesDelete200Response> {
            return localVarFp.studentsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a student by its CUID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentsGet(id: string, options?: any): AxiosPromise<StudentsGet200Response> {
            return localVarFp.studentsGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all students
         * @param {number} [perPage] The number of results to retrieve in each page.
         * @param {number} [page] The page to load.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentsList(perPage?: number, page?: number, options?: any): AxiosPromise<StudentsListResponse> {
            return localVarFp.studentsList(perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a student by its CUID
         * @param {string} id 
         * @param {StudentsUpdateRequest} studentsUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        studentsUpdate(id: string, studentsUpdateRequest: StudentsUpdateRequest, options?: any): AxiosPromise<StudentsUpdateResponse> {
            return localVarFp.studentsUpdate(id, studentsUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudentsApi - object-oriented interface
 * @export
 * @class StudentsApi
 * @extends {BaseAPI}
 */
export class StudentsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new student
     * @param {StudentsCreateRequest} studentsCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public studentsCreate(studentsCreateRequest: StudentsCreateRequest, options?: AxiosRequestConfig) {
        return StudentsApiFp(this.configuration).studentsCreate(studentsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a student by its CUID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public studentsDelete(id: string, options?: AxiosRequestConfig) {
        return StudentsApiFp(this.configuration).studentsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a student by its CUID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public studentsGet(id: string, options?: AxiosRequestConfig) {
        return StudentsApiFp(this.configuration).studentsGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all students
     * @param {number} [perPage] The number of results to retrieve in each page.
     * @param {number} [page] The page to load.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public studentsList(perPage?: number, page?: number, options?: AxiosRequestConfig) {
        return StudentsApiFp(this.configuration).studentsList(perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a student by its CUID
     * @param {string} id 
     * @param {StudentsUpdateRequest} studentsUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public studentsUpdate(id: string, studentsUpdateRequest: StudentsUpdateRequest, options?: AxiosRequestConfig) {
        return StudentsApiFp(this.configuration).studentsUpdate(id, studentsUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeachersApi - axios parameter creator
 * @export
 */
export const TeachersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new teacher
         * @param {TeachersCreateRequest} teachersCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teachersCreate: async (teachersCreateRequest: TeachersCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teachersCreateRequest' is not null or undefined
            assertParamExists('teachersCreate', 'teachersCreateRequest', teachersCreateRequest)
            const localVarPath = `/v1/teachers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teachersCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a teacher by its CUID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teachersDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('teachersDelete', 'id', id)
            const localVarPath = `/v1/teachers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a teacher by its CUID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teachersGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('teachersGet', 'id', id)
            const localVarPath = `/v1/teachers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all teachers
         * @param {number} [perPage] The number of results to retrieve in each page.
         * @param {number} [page] The page to load.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teachersList: async (perPage?: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/teachers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a teacher by its CUID
         * @param {string} id 
         * @param {TeachersUpdateRequest} teachersUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teachersUpdate: async (id: string, teachersUpdateRequest: TeachersUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('teachersUpdate', 'id', id)
            // verify required parameter 'teachersUpdateRequest' is not null or undefined
            assertParamExists('teachersUpdate', 'teachersUpdateRequest', teachersUpdateRequest)
            const localVarPath = `/v1/teachers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teachersUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeachersApi - functional programming interface
 * @export
 */
export const TeachersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeachersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new teacher
         * @param {TeachersCreateRequest} teachersCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teachersCreate(teachersCreateRequest: TeachersCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeachersCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teachersCreate(teachersCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a teacher by its CUID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teachersDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassesDelete200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teachersDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a teacher by its CUID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teachersGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeachersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teachersGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all teachers
         * @param {number} [perPage] The number of results to retrieve in each page.
         * @param {number} [page] The page to load.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teachersList(perPage?: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeachersListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teachersList(perPage, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a teacher by its CUID
         * @param {string} id 
         * @param {TeachersUpdateRequest} teachersUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teachersUpdate(id: string, teachersUpdateRequest: TeachersUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeachersUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teachersUpdate(id, teachersUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeachersApi - factory interface
 * @export
 */
export const TeachersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeachersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new teacher
         * @param {TeachersCreateRequest} teachersCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teachersCreate(teachersCreateRequest: TeachersCreateRequest, options?: any): AxiosPromise<TeachersCreateResponse> {
            return localVarFp.teachersCreate(teachersCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a teacher by its CUID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teachersDelete(id: string, options?: any): AxiosPromise<ClassesDelete200Response> {
            return localVarFp.teachersDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a teacher by its CUID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teachersGet(id: string, options?: any): AxiosPromise<TeachersGet200Response> {
            return localVarFp.teachersGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all teachers
         * @param {number} [perPage] The number of results to retrieve in each page.
         * @param {number} [page] The page to load.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teachersList(perPage?: number, page?: number, options?: any): AxiosPromise<TeachersListResponse> {
            return localVarFp.teachersList(perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a teacher by its CUID
         * @param {string} id 
         * @param {TeachersUpdateRequest} teachersUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teachersUpdate(id: string, teachersUpdateRequest: TeachersUpdateRequest, options?: any): AxiosPromise<TeachersUpdateResponse> {
            return localVarFp.teachersUpdate(id, teachersUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeachersApi - object-oriented interface
 * @export
 * @class TeachersApi
 * @extends {BaseAPI}
 */
export class TeachersApi extends BaseAPI {
    /**
     * 
     * @summary Create a new teacher
     * @param {TeachersCreateRequest} teachersCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public teachersCreate(teachersCreateRequest: TeachersCreateRequest, options?: AxiosRequestConfig) {
        return TeachersApiFp(this.configuration).teachersCreate(teachersCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a teacher by its CUID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public teachersDelete(id: string, options?: AxiosRequestConfig) {
        return TeachersApiFp(this.configuration).teachersDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a teacher by its CUID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public teachersGet(id: string, options?: AxiosRequestConfig) {
        return TeachersApiFp(this.configuration).teachersGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all teachers
     * @param {number} [perPage] The number of results to retrieve in each page.
     * @param {number} [page] The page to load.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public teachersList(perPage?: number, page?: number, options?: AxiosRequestConfig) {
        return TeachersApiFp(this.configuration).teachersList(perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a teacher by its CUID
     * @param {string} id 
     * @param {TeachersUpdateRequest} teachersUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public teachersUpdate(id: string, teachersUpdateRequest: TeachersUpdateRequest, options?: AxiosRequestConfig) {
        return TeachersApiFp(this.configuration).teachersUpdate(id, teachersUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


